/**
 *  @file RC4.c
 *  @author Daniel Black, Algorithm by Ron Rivest
 *  @date February 2012
 *  @details Contains a modified RC4 algorithm
 *  Requires initkey to be an array of chars.
 *  At any time you may add,modify,xor something with,etc the public variable rng_state
 *  to add more entropy. The initializer was also modded to produce a non-identity permutation.
 *  the generated bytestream is as random as RC4 but is not the same for a given key.
 *
 */




//keystream generator based rng
//Feel free to use this for any purpose that doesn't hurt anything.
//this basically whitens any input stream. rnginput should be defined to some constantly changing input.
//if you leave rnginput undefined it will assume a key made up of all 31s
//Don't use this for anything important without using you're best judgement.
//not responsible for any results of using this.



#include "global.h" //We must include this before data.h
/**included only because of the initializer key*/
#include "data.h"
/**internal state vars*/
#pragma udata rc4rngs
static unsigned char rngs[256];
#pragma udata rc4ijk
/**more internal state vars*/
static unsigned char rngj, rngi, rngk;


#ifndef rnginput
#define rnginput rng_state
#endif


/**an entropy pool made by addng the aufo to this var. used to mix into rc4 to create variation*/
unsigned char rng_state = 31;

/**Initialize the rng. Expets unsigned char initkey[8] to be defined in data.h*/
void setup_rng()
{
    //generate a weird permutation, then permute it by rc4's init function.
    for (rngi = 0; rngi < 255; rngi = rngi + 1) {
        rngs[rngi] = rngi + 93;
    }
    rngs[255] = 92; //fill in a missing space

    for (rngi = 0; rngi < 255; rngi = rngi + 1) {
        rngj += (rngs[rngi] + InitKey[rngi & 7]);
        rngk = rngs[rngi];
        rngs[rngi] = rngs[rngj];
        rngs[rngj] = rngk;
        rngk = rngs[(rngs[rngi] + rngs[rngj])&255];
    }
}

/**return 1 high quality RC4 generated random byte. The RC4 algorithm is modified and adds rng_state to j so that repeats are avoided. @returns an unsigned char that is uniformly distributed from 0-255*/
unsigned char random() //return 1 random byte
{
    rngi++;
    rngj += (rngs[rngi] + rnginput);
    rngk = rngs[rngi];
    rngs[rngi] = rngs[rngj];
    rngs[rngj] = rngk;
    rngk = rngs[(rngs[rngi] + rngs[rngj])&255];
    return rngk;
}